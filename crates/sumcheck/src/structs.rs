use ff_ext::ExtensionField;
use multilinear_extensions::{virtual_poly::VirtualPolynomial, virtual_polys::PolyMeta};
use serde::{Deserialize, Serialize, de::DeserializeOwned};
use thiserror::Error;
use transcript::Challenge;

/// An IOP proof is a collections of
/// - messages from prover to verifier at each round through the interactive protocol.
/// - a point that is generated by the transcript for evaluation
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(bound(
    serialize = "E::BaseField: Serialize",
    deserialize = "E::BaseField: DeserializeOwned"
))]
pub struct IOPProof<E: ExtensionField> {
    pub proofs: Vec<IOPProverMessage<E>>,
}
impl<E: ExtensionField> IOPProof<E> {
    pub fn extract_sum(&self) -> E {
        self.proofs[0].evaluations[0] + self.proofs[0].evaluations[1]
    }
}

/// A message from the prover to the verifier at a given round
/// is a list of evaluations.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(bound(
    serialize = "E::BaseField: Serialize",
    deserialize = "E::BaseField: DeserializeOwned"
))]
pub struct IOPProverMessage<E: ExtensionField> {
    pub evaluations: Vec<E>,
}

/// Prover State of a PolyIOP.
#[derive(Default)]
pub struct IOPProverState<'a, E: ExtensionField> {
    pub is_main_worker: bool,
    /// sampled randomness given by the verifier
    pub challenges: Vec<Challenge<E>>,
    /// the current round number
    pub(crate) round: usize,
    /// pointer to the virtual polynomial
    pub(crate) poly: VirtualPolynomial<'a, E>,
    pub(crate) max_num_variables: usize,
    pub(crate) poly_meta: Vec<PolyMeta>,
    /// phase 1 and phase 2 sumcheck we share similar implementation
    /// thus this option variable only use for phase 1 sumcheck to mark how many variables belongs to phase 2
    pub(crate) phase2_numvar: Option<usize>,
}

/// Prover State of a PolyIOP
pub struct IOPVerifierState<E: ExtensionField> {
    pub(crate) round: usize,
    pub(crate) num_vars: usize,
    pub(crate) max_degree: usize,
    pub(crate) finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub(crate) polynomials_received: Vec<Vec<E>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub(crate) challenges: Vec<Challenge<E>>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<E: ExtensionField> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<Challenge<E>>,
    /// the expected evaluation
    pub expected_evaluation: E,
}

#[derive(Clone, Debug, Error)]
pub enum VerifierError {
    #[error("Claim not match: expect: {0:?}, got: {1:?}")]
    ClaimNotMatch(Box<str>, Box<str>),
}
